QBCore = exports['qb-core']:GetCoreObject()

local isOnDuty = false
local isNearTurbine = false
local currentSystems = {
    stability = Config.InitialSystemValue,
    electric = Config.InitialSystemValue,
    lubrication = Config.InitialSystemValue,
    blades = Config.InitialSystemValue,
    safety = Config.InitialSystemValue
}
local currentEfficiency = 0
local currentEarnings = 0
local workStartTime = 0
local lastEarningTime = 0
local lastPenaltyTime = 0
local totalWorkHours = 0
local dailyWorkHours = 0
local weeklyWorkHours = 0
local lastDayReset = os.date("%Y-%m-%d")
local lastWeekReset = os.date("%Y-W%W")

-- ============================================
-- CLIENT-SIDE CALCULATIONS (Gi·∫£m t·∫£i server)
-- ============================================

-- T√≠nh hi·ªáu su·∫•t t·ªïng (trung b√¨nh 5 ch·ªâ s·ªë)
local function CalculateEfficiency()
    local total = currentSystems.stability + currentSystems.electric + 
                  currentSystems.lubrication + currentSystems.blades + 
                  currentSystems.safety
    return total / 5
end

-- T√≠nh l·ª£i nhu·∫≠n d·ª±a tr√™n t·ª´ng ch·ªâ s·ªë (CLIENT-SIDE)
local function CalculateSystemProfit()
    local totalProfit = 0
    
    for systemName, value in pairs(currentSystems) do
        local systemProfit = Config.BaseSalary * (Config.SystemProfitContribution / 100)
        
        if value < 30 then
            systemProfit = 0
        elseif value < 50 then
            systemProfit = systemProfit * 0.5
        end
        
        totalProfit = totalProfit + systemProfit
    end
    
    return totalProfit
end

-- Ki·ªÉm tra ƒëi·ªÅu ki·ªán sinh ti·ªÅn (CLIENT-SIDE)
local function CanEarnMoney()
    local below30 = 0
    
    for _, value in pairs(currentSystems) do
        if value < 30 then below30 = below30 + 1 end
    end
    
    if below30 >= 3 then 
        return false, "STOPPED"
    end
    
    return true, "RUNNING"
end

-- √Åp d·ª•ng penalty (CLIENT-SIDE)
local function ApplyPenalty()
    if not isOnDuty then return end
    
    local workHours = totalWorkHours
    
    -- T√¨m penalty range
    local penaltyRange = nil
    for _, range in ipairs(Config.PenaltyRanges) do
        if workHours >= range.minHours and workHours < range.maxHours then
            penaltyRange = range
            break
        end
    end
    
    if not penaltyRange or #penaltyRange.penalties == 0 then 
        return 
    end
    
    -- Random penalty
    local roll = math.random(1, 100)
    local cumulativeChance = 0
    local selectedPenalty = nil
    
    for _, penalty in ipairs(penaltyRange.penalties) do
        cumulativeChance = cumulativeChance + penalty.chance
        if roll <= cumulativeChance then
            selectedPenalty = penalty
            break
        end
    end
    
    if not selectedPenalty or selectedPenalty.systems == 0 then 
        QBCore.Functions.Notify('‚úÖ May m·∫Øn! Kh√¥ng c√≥ h∆∞ h·ªèng n√†o x·∫£y ra!', 'success', 3000)
        return 
    end
    
    -- X√°c ƒë·ªãnh s·ªë l∆∞·ª£ng h·ªá th·ªëng b·ªã ·∫£nh h∆∞·ªüng
    local numSystems = selectedPenalty.systems
    if type(numSystems) == "table" then
        numSystems = math.random(numSystems[1], numSystems[2])
    end
    
    -- Random ch·ªçn h·ªá th·ªëng b·ªã ·∫£nh h∆∞·ªüng
    local systemNames = {"stability", "electric", "lubrication", "blades", "safety"}
    local systemDisplayNames = {
        stability = "ƒê·ªô ·ªïn ƒë·ªãnh",
        electric = "H·ªá th·ªëng ƒëi·ªán",
        lubrication = "B√¥i tr∆°n",
        blades = "Th√¢n th√°p",
        safety = "An to√†n"
    }
    local systemDetails = {}
    
    for i = 1, numSystems do
        local randomIndex = math.random(1, #systemNames)
        local systemName = table.remove(systemNames, randomIndex)
        
        local beforeValue = currentSystems[systemName]
        local afterValue = math.max(0, beforeValue - selectedPenalty.damage)
        currentSystems[systemName] = afterValue
        
        table.insert(systemDetails, string.format('%s: %d%% ‚Üí %d%%', 
            systemDisplayNames[systemName], beforeValue, afterValue))
    end
    
    -- Update UI
    currentEfficiency = CalculateEfficiency()
    local actualEarningRate = CalculateSystemProfit() * 4
    
    SendNUIMessage({
        action = 'updateSystems',
        systems = currentSystems
    })
    SendNUIMessage({
        action = 'updateEfficiency',
        efficiency = currentEfficiency
    })
    SendNUIMessage({
        action = 'updateActualEarningRate',
        earningRate = actualEarningRate
    })
    
    -- Th√¥ng b√°o
    local detailsText = table.concat(systemDetails, ' | ')
    QBCore.Functions.Notify(
        string.format('‚ö†Ô∏è Penalty! Gi·∫£m %d%%: %s', selectedPenalty.damage, detailsText), 
        'error', 7000)
    PlaySound(-1, "CHECKPOINT_MISSED", "HUD_MINI_GAME_SOUNDSET", 0, 0, 1)
end

-- Ki·ªÉm tra gi·ªõi h·∫°n th·ªùi gian (CLIENT-SIDE)
local function CheckTimeLimit()
    local currentDay = os.date("%Y-%m-%d")
    local currentWeek = os.date("%Y-W%W")
    
    -- Reset daily counter
    if lastDayReset ~= currentDay then
        dailyWorkHours = 0
        lastDayReset = currentDay
        SendNUIMessage({ action = 'resetWorkLimit' })
    end
    
    -- Reset weekly counter
    if lastWeekReset ~= currentWeek then
        weeklyWorkHours = 0
        lastWeekReset = currentWeek
        SendNUIMessage({ action = 'resetWorkLimit' })
    end
    
    -- Ki·ªÉm tra gi·ªõi h·∫°n
    if dailyWorkHours >= Config.MaxDailyHours then
        return false, "DAILY_LIMIT"
    end
    
    if weeklyWorkHours >= Config.MaxWeeklyHours then
        return false, "WEEKLY_LIMIT"
    end
    
    return true, "OK"
end

-- M·ªü UI ch√≠nh
local function OpenMainUI()
    SetNuiFocus(true, true)
    SendNUIMessage({
        action = 'showMainUI',
        systems = currentSystems,
        efficiency = currentEfficiency,
        earnings = currentEarnings,
        onDuty = isOnDuty,
        workHours = totalWorkHours,
        maxHours = Config.MaxDailyHours
    })
end

-- ƒê√≥ng UI
local function CloseUI()
    SetNuiFocus(false, false)
    SendNUIMessage({
        action = 'hideUI'
    })
end

-- M·ªü minigame
local function OpenMinigame(system)
    local settings = Config.MinigameSettings[system]
    if not settings then return end
    
    SetNuiFocus(true, true)
    SendNUIMessage({
        action = 'showMinigame',
        system = system,
        title = settings.title,
        speed = settings.speed,
        zoneSize = settings.zoneSize,
        rounds = settings.rounds
    })
end

-- M·ªü UI qu·ªπ ti·ªÅn
local function OpenEarningsUI()
    SetNuiFocus(true, true)
    SendNUIMessage({
        action = 'showEarningsUI',
        earnings = currentEarnings,
        efficiency = currentEfficiency
    })
end

-- NUI Callbacks
RegisterNUICallback('close', function(data, cb)
    CloseUI()
    cb('ok')
end)

RegisterNUICallback('startDuty', function(data, cb)
    -- Ki·ªÉm tra gi·ªõi h·∫°n th·ªùi gian (CLIENT-SIDE)
    local canWork, reason = CheckTimeLimit()
    if not canWork then
        if reason == "DAILY_LIMIT" then
            QBCore.Functions.Notify('‚ùå ƒê√£ ƒë·∫°t gi·ªõi h·∫°n! H√£y quay l·∫°i v√†o ng√†y mai.', 'error', 5000)
            SendNUIMessage({ action = 'workLimitReached' })
        elseif reason == "WEEKLY_LIMIT" then
            QBCore.Functions.Notify('‚ùå ƒê√£ ƒë·∫°t gi·ªõi h·∫°n tu·∫ßn! H√£y quay l·∫°i v√†o tu·∫ßn sau.', 'error', 5000)
            SendNUIMessage({ action = 'workLimitReached' })
        end
        cb('ok')
        return
    end
    
    -- Ch·ªâ th√¥ng b√°o server ƒë·ªÉ l∆∞u tr·∫°ng th√°i
    TriggerServerEvent('windturbine:startDuty')
    
    isOnDuty = true
    workStartTime = GetGameTimer() / 1000 -- seconds
    lastEarningTime = workStartTime
    lastPenaltyTime = workStartTime
    totalWorkHours = 0
    
    -- Reset systems v·ªÅ gi√° tr·ªã ban ƒë·∫ßu
    currentSystems = {
        stability = Config.InitialSystemValue,
        electric = Config.InitialSystemValue,
        lubrication = Config.InitialSystemValue,
        blades = Config.InitialSystemValue,
        safety = Config.InitialSystemValue
    }
    
    currentEfficiency = CalculateEfficiency()
    local actualEarningRate = CalculateSystemProfit() * 4
    
    -- Update UI ngay l·∫≠p t·ª©c
    SendNUIMessage({
        action = 'updateSystems',
        systems = currentSystems
    })
    SendNUIMessage({
        action = 'updateEfficiency',
        efficiency = currentEfficiency
    })
    SendNUIMessage({
        action = 'updateActualEarningRate',
        earningRate = actualEarningRate
    })
    SendNUIMessage({
        action = 'updateWorkTime',
        workHours = 0,
        maxHours = Config.MaxDailyHours
    })
    
    QBCore.Functions.Notify('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác t·∫°i c·ªëi xay gi√≥!', 'success', 3000)
    PlaySound(-1, "CHECKPOINT_PERFECT", "HUD_MINI_GAME_SOUNDSET", 0, 0, 1)
    
    cb('ok')
end)

RegisterNUICallback('stopDuty', function(data, cb)
    if isOnDuty then
        -- T√≠nh th·ªùi gian l√†m vi·ªác
        local currentTime = GetGameTimer() / 1000
        local workDuration = (currentTime - workStartTime) / 3600 -- gi·ªù
        dailyWorkHours = dailyWorkHours + workDuration
        weeklyWorkHours = weeklyWorkHours + workDuration
        
        -- G·ª≠i server ƒë·ªÉ l∆∞u earnings v√† work hours
        TriggerServerEvent('windturbine:stopDuty', {
            earnings = currentEarnings,
            dailyHours = dailyWorkHours,
            weeklyHours = weeklyWorkHours
        })
        
        isOnDuty = false
        
        CloseUI()
        
        QBCore.Functions.Notify('üëã ƒê√£ k·∫øt th√∫c ca l√†m vi·ªác!', 'primary', 3000)
        PlaySound(-1, "QUIT", "HUD_FRONTEND_DEFAULT_SOUNDSET", 0, 0, 1)
        
        -- Reset UI
        SendNUIMessage({
            action = 'resetToInitialState'
        })
    end
    
    cb('ok')
end)

RegisterNUICallback('repair', function(data, cb)
    if data.system then
        OpenMinigame(data.system)
    end
    cb('ok')
end)

RegisterNUICallback('minigameResult', function(data, cb)
    if not isOnDuty then 
        cb('ok')
        return 
    end
    
    local system = data.system
    local result = data.result
    
    -- T√≠nh reward (CLIENT-SIDE)
    local reward = 0
    if result == 'perfect' then
        reward = Config.RepairRewards.perfect
    elseif result == 'good' then
        reward = Config.RepairRewards.good
    else
        reward = Config.RepairRewards.fail
    end
    
    local beforeValue = currentSystems[system]
    currentSystems[system] = math.min(100, currentSystems[system] + reward)
    local afterValue = currentSystems[system]
    
    -- Update efficiency v√† earning rate
    currentEfficiency = CalculateEfficiency()
    local actualEarningRate = CalculateSystemProfit() * 4
    
    -- Update UI
    SendNUIMessage({
        action = 'updateSystems',
        systems = currentSystems
    })
    SendNUIMessage({
        action = 'updateEfficiency',
        efficiency = currentEfficiency
    })
    SendNUIMessage({
        action = 'updateActualEarningRate',
        earningRate = actualEarningRate
    })
    
    -- Th√¥ng b√°o k·∫øt qu·∫£
    if result == 'perfect' then
        QBCore.Functions.Notify('üåü Ho√†n h·∫£o! H·ªá th·ªëng ' .. system:upper() .. ' ƒë√£ ƒë∆∞·ª£c s·ª≠a ch·ªØa t·ªët!', 'success', 3000)
        PlaySound(-1, "CHECKPOINT_PERFECT", "HUD_MINI_GAME_SOUNDSET", 0, 0, 1)
    elseif result == 'good' then
        QBCore.Functions.Notify('‚úÖ T·ªët! H·ªá th·ªëng ' .. system:upper() .. ' ƒë√£ ƒë∆∞·ª£c c·∫£i thi·ªán!', 'success', 3000)
        PlaySound(-1, "CHECKPOINT_NORMAL", "HUD_MINI_GAME_SOUNDSET", 0, 0, 1)
    else
        QBCore.Functions.Notify('‚ùå Th·∫•t b·∫°i! H·ªá th·ªëng ' .. system:upper() .. ' b·ªã gi·∫£m hi·ªáu su·∫•t!', 'error', 3000)
        PlaySound(-1, "CHECKPOINT_MISSED", "HUD_MINI_GAME_SOUNDSET", 0, 0, 1)
    end
    
    -- ƒê·ª£i 2.5 gi√¢y tr∆∞·ªõc khi ƒë√≥ng v√† m·ªü l·∫°i UI
    Wait(2500)
    CloseUI()
    Wait(300)
    OpenMainUI()
    cb('ok')
end)

RegisterNUICallback('openEarnings', function(data, cb)
    OpenEarningsUI()
    cb('ok')
end)

RegisterNUICallback('withdrawEarnings', function(data, cb)
    if currentEarnings <= 0 then
        QBCore.Functions.Notify('‚ùå Kh√¥ng c√≥ ti·ªÅn ƒë·ªÉ r√∫t!', 'error')
        cb('ok')
        return
    end
    
    -- G·ª≠i server ƒë·ªÉ x·ª≠ l√Ω ti·ªÅn (CH·ªà VI·ªÜC N√ÄY C·∫¶N SERVER)
    TriggerServerEvent('windturbine:withdrawEarnings', math.floor(currentEarnings))
    
    PlaySound(-1, "PICK_UP", "HUD_FRONTEND_DEFAULT_SOUNDSET", 0, 0, 1)
    cb('ok')
end)

RegisterNUICallback('backToMain', function(data, cb)
    OpenMainUI()
    cb('ok')
end)

-- Server Events (CH·ªà NH·∫¨N K·∫æT QU·∫¢ T·ª™ SERVER)
RegisterNetEvent('windturbine:withdrawSuccess')
AddEventHandler('windturbine:withdrawSuccess', function(amount)
    currentEarnings = 0
    SendNUIMessage({
        action = 'updateEarnings',
        earnings = 0
    })
    QBCore.Functions.Notify(string.format('üí∞ ƒê√£ r√∫t $%d t·ª´ qu·ªπ ti·ªÅn l∆∞∆°ng!', amount), 'success')
end)

RegisterNetEvent('windturbine:stopTurbine')
AddEventHandler('windturbine:stopTurbine', function()
    isOnDuty = false
    
    -- Reset UI v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
    SendNUIMessage({
        action = 'resetToInitialState'
    })
    
    CloseUI()
end)

RegisterNetEvent('windturbine:workLimitReached')
AddEventHandler('windturbine:workLimitReached', function()
    -- G·ª≠i th√¥ng b√°o ƒë·∫øn UI ƒë·ªÉ disable n√∫t Start
    SendNUIMessage({
        action = 'workLimitReached'
    })
end)

-- ============================================
-- CLIENT-SIDE EARNING LOOP (Gi·∫£m t·∫£i server)
-- ============================================
CreateThread(function()
    while true do
        Wait(1000) -- Check m·ªói gi√¢y
        
        if isOnDuty then
            local currentTime = GetGameTimer() / 1000
            
            -- T√≠nh th·ªùi gian l√†m vi·ªác hi·ªán t·∫°i
            totalWorkHours = (currentTime - workStartTime) / 3600
            
            -- Ki·ªÉm tra gi·ªõi h·∫°n th·ªùi gian
            local totalDailyHours = dailyWorkHours + totalWorkHours
            local totalWeeklyHours = weeklyWorkHours + totalWorkHours
            
            -- Auto-stop khi h·∫øt gi·ªù
            if totalDailyHours >= Config.MaxDailyHours then
                isOnDuty = false
                CloseUI()
                
                QBCore.Functions.Notify('‚è∞ ƒê√£ h·∫øt gi·ªù l√†m vi·ªác trong ng√†y! Ca l√†m vi·ªác t·ª± ƒë·ªông k·∫øt th√∫c.', 'error', 5000)
                
                -- G·ª≠i server ƒë·ªÉ l∆∞u
                TriggerServerEvent('windturbine:stopDuty', {
                    earnings = currentEarnings,
                    dailyHours = totalDailyHours,
                    weeklyHours = totalWeeklyHours
                })
                
                dailyWorkHours = totalDailyHours
                weeklyWorkHours = totalWeeklyHours
                
                SendNUIMessage({ action = 'resetToInitialState' })
                goto continue
            end
            
            if totalWeeklyHours >= Config.MaxWeeklyHours then
                isOnDuty = false
                CloseUI()
                
                QBCore.Functions.Notify('‚è∞ ƒê√£ h·∫øt gi·ªù l√†m vi·ªác trong tu·∫ßn! Ca l√†m vi·ªác t·ª± ƒë·ªông k·∫øt th√∫c.', 'error', 5000)
                
                -- G·ª≠i server ƒë·ªÉ l∆∞u
                TriggerServerEvent('windturbine:stopDuty', {
                    earnings = currentEarnings,
                    dailyHours = totalDailyHours,
                    weeklyHours = totalWeeklyHours
                })
                
                dailyWorkHours = totalDailyHours
                weeklyWorkHours = totalWeeklyHours
                
                SendNUIMessage({ action = 'resetToInitialState' })
                goto continue
            end
            
            -- Sinh ti·ªÅn m·ªói chu k·ª≥ (CLIENT-SIDE)
            if currentTime - lastEarningTime >= (Config.EarningCycle / 1000) then
                local canEarn, status = CanEarnMoney()
                
                if canEarn then
                    local earnings = CalculateSystemProfit()
                    if earnings > 0 then
                        currentEarnings = currentEarnings + earnings
                        lastEarningTime = currentTime
                        
                        SendNUIMessage({
                            action = 'updateEarnings',
                            earnings = currentEarnings
                        })
                        
                        -- Th√¥ng b√°o thu nh·∫≠p
                        local efficiency = CalculateEfficiency()
                        if efficiency >= 80 then
                            QBCore.Functions.Notify(string.format('üíµ +$%d IC | Hi·ªáu su·∫•t tuy·ªát v·ªùi!', math.floor(earnings)), 'success', 2000)
                        elseif efficiency >= 50 then
                            QBCore.Functions.Notify(string.format('üíµ +$%d IC', math.floor(earnings)), 'primary', 2000)
                        end
                    end
                else
                    -- M√°y ng·ª´ng ho·∫°t ƒë·ªông
                    QBCore.Functions.Notify('üö® M√°y ng·ª´ng ho·∫°t ƒë·ªông! 3 ch·ªâ s·ªë d∆∞·ªõi 30%! C·∫ßn s·ª≠a ch·ªØa ngay!', 'error', 5000)
                    lastEarningTime = currentTime
                end
            end
            
            -- √Åp d·ª•ng penalty m·ªói gi·ªù (CLIENT-SIDE)
            if currentTime - lastPenaltyTime >= (Config.PenaltyCycle / 1000) then
                -- Update work time
                SendNUIMessage({
                    action = 'updateWorkTime',
                    workHours = totalWorkHours,
                    maxHours = Config.MaxDailyHours
                })
                
                -- Apply penalty
                ApplyPenalty()
                lastPenaltyTime = currentTime
            end
        end
        
        ::continue::
    end
end)

-- Thread: Ki·ªÉm tra kho·∫£ng c√°ch
CreateThread(function()
    local lastWarningTime = 0
    
    while true do
        Wait(1000)
        
        local playerPed = PlayerPedId()
        local playerCoords = GetEntityCoords(playerPed)
        local turbineCoords = Config.TurbineLocation
        local distance = math.sqrt(
            math.pow(playerCoords.x - turbineCoords.x, 2) +
            math.pow(playerCoords.y - turbineCoords.y, 2) +
            math.pow(playerCoords.z - turbineCoords.z, 2)
        )
        
        isNearTurbine = distance < 5.0
        
        -- C·∫£nh b√°o khi r·ªùi xa trong khi ƒëang l√†m vi·ªác (kh√¥ng t·ª± ƒë·ªông k·∫øt th√∫c ca)
        if isOnDuty and distance > 50.0 then
            local currentTime = GetGameTimer()
            -- Ch·ªâ th√¥ng b√°o m·ªói 30 gi√¢y ƒë·ªÉ tr√°nh spam
            if currentTime - lastWarningTime > 30000 then
                QBCore.Functions.Notify('‚ö†Ô∏è B·∫°n ƒëang r·ªùi xa c·ªëi xay gi√≥! Ca l√†m vi·ªác v·∫´n ti·∫øp t·ª•c.', 'warning', 5000)
                lastWarningTime = currentTime
            end
        end
    end
end)

-- Thread: Hi·ªÉn th·ªã marker v√† text
CreateThread(function()
    while true do
        Wait(0)
        
        if isNearTurbine then
            DrawMarker(1, Config.TurbineLocation.x, Config.TurbineLocation.y, Config.TurbineLocation.z - 1.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0, 1.0, 0, 255, 0, 100, false, true, 2, false, nil, nil, false)
            
            if not isOnDuty then
                DrawText3D(Config.TurbineLocation.x, Config.TurbineLocation.y, Config.TurbineLocation.z,
                    "[~g~E~w~] B·∫Øt ƒë·∫ßu ca l√†m vi·ªác")
                
                if IsControlJustReleased(0, 38) then -- E
                    OpenMainUI()
                end
            else
                DrawText3D(Config.TurbineLocation.x, Config.TurbineLocation.y, Config.TurbineLocation.z,
                    "[~g~E~w~] M·ªü b·∫£ng ƒëi·ªÅu khi·ªÉn")
                
                if IsControlJustReleased(0, 38) then -- E
                    OpenMainUI()
                end
            end
        end
    end
end)

-- Helper: Draw 3D Text
function DrawText3D(x, y, z, text)
    local onScreen, _x, _y = World3dToScreen2d(x, y, z)
    local px, py, pz = table.unpack(GetGameplayCamCoords())
    
    SetTextScale(0.35, 0.35)
    SetTextFont(4)
    SetTextProportional(1)
    SetTextColour(255, 255, 255, 215)
    SetTextEntry("STRING")
    SetTextCentre(1)
    AddTextComponentString(text)
    DrawText(_x, _y)
end
